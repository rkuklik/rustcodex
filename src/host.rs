use std::cell::RefCell;
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use std::io;
use std::io::BufRead;
use std::io::ErrorKind;
use std::io::Write;

use base64::prelude::BASE64_STANDARD;
use base64::write::EncoderWriter;
use flate2::write::ZlibEncoder;
use flate2::Compression;

use crate::source::Source;

struct IoCompat<'m, 'f> {
    f: &'m mut Formatter<'f>,
}

impl<'m, 'f> Write for IoCompat<'m, 'f> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let text = std::str::from_utf8(buf)
            .map_err(|error| io::Error::new(ErrorKind::InvalidData, error))?;
        self.f
            .write_str(text)
            .map_err(|error| io::Error::new(ErrorKind::Other, error))?;
        Ok(text.len())
    }
    fn flush(&mut self) -> io::Result<()> {
        Ok(())
    }
}

struct PayloadBuilder<'a, R: BufRead> {
    reader: &'a RefCell<R>,
    compress: bool,
}

impl<'a, R: BufRead> Display for PayloadBuilder<'a, R> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        macro_rules! looper {
            ($reader:ident, $writer:ident) => {
                loop {
                    let part = $reader.fill_buf().expect("reading native code failed");
                    let len = part.len();
                    if len == 0 {
                        break;
                    }
                    $writer.write_all(part).expect("writing native code failed");
                    $reader.consume(len);
                }
                $writer.finish().expect("writing native code failed");
            };
        }

        let Self { reader, compress } = *self;
        let iocompat = IoCompat { f };
        let mut reader = reader.borrow_mut();
        if compress {
            let mut writer = ZlibEncoder::new(
                EncoderWriter::new(iocompat, &BASE64_STANDARD),
                Compression::best(),
            );
            looper!(reader, writer);
        } else {
            let mut writer = EncoderWriter::new(iocompat, &BASE64_STANDARD);
            looper!(reader, writer);
        }

        Ok(())
    }
}

macro_rules! template {
    (
        name: $name:ident
        $(shebang: $shebang:literal)?
        $(comment: $comment:literal)?
        rawloader: $rawloader:literal
        compressloader: $compressloader:literal
        executor: $exec:literal
    ) => {
        pub struct $name<R, S>
        where
            R: BufRead + 'static,
            S: Source + 'static,
        {
            reader: RefCell<R>,
            sources: S,
            compress: bool,
        }

        impl<R, S> $name<R, S>
        where
            R: BufRead + 'static,
            S: Source + 'static,
        {
            pub fn new(payload: R, sources: S, compress: bool) -> Self {
                Self {
                    reader: RefCell::new(payload),
                    sources,
                    compress,
                }
            }
        }

        impl<R, S> fmt::Display for $name<R, S>
        where
            R: BufRead + 'static,
            S: Source + 'static,
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let Self {
                    reader,
                    sources,
                    compress,
                } = self;
                let compress = *compress;

                $(
                writeln!(f, concat!("#!", $shebang))?;
                )?

                $(
                writeln!(f, concat!($comment, "Generated by `rustcodex`"))?;
                writeln!(f, $comment)?;
                writeln!(
                    f,
                    concat!($comment, "Heuristically determined source files:")
                )?;

                for source in sources.sources().expect("source inclusion failed") {
                    writeln!(f, concat!($comment, "SOURCE FILE: {}"), source.name)?;
                    for line in source.code.lines() {
                        writeln!(f, concat!($comment, "{}"), line)?;
                    }
                }
                )?

                write!(
                    f,
                    $exec,
                    PayloadBuilder { reader, compress },
                    if compress {
                        $compressloader
                    } else {
                        $rawloader
                    }
                )?;

                Ok(())
            }
        }
    };
}

template! {
name: Python
shebang: "/usr/bin/env python3"
comment: "# "
rawloader: "base64.standard_b64decode(payload)"
compressloader: "zlib.decompress(base64.standard_b64decode(payload))"
executor: r#"
import base64
import os
import sys
import tempfile
import zlib

payload = """{}"""
binary = {}

fd, name = tempfile.mkstemp()
os.write(fd, binary)
os.close(fd)

os.chmod(name, 0o700)

args = list(sys.argv)
args[0] = name
os.execv(name, args)
"#
}
