use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use std::io;
use std::io::ErrorKind;
use std::io::Write;
use std::marker::PhantomData;

use base64::prelude::BASE64_STANDARD;
use base64::write::EncoderWriter;
use flate2::write::ZlibEncoder;
use flate2::Compression;

use crate::source::SourceFile;

struct IoCompat<'m, 'f> {
    f: &'m mut Formatter<'f>,
}

impl<'m, 'f> Write for IoCompat<'m, 'f> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let text = std::str::from_utf8(buf)
            .map_err(|error| io::Error::new(ErrorKind::InvalidData, error))?;
        self.f
            .write_str(text)
            .map_err(|error| io::Error::new(ErrorKind::Other, error))?;
        Ok(text.len())
    }
    fn flush(&mut self) -> io::Result<()> {
        Ok(())
    }
}

struct Compressor<'a> {
    payload: &'a [u8],
}

impl<'a> Display for Compressor<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let iocompat = IoCompat { f };
        let error = "payload builder wrote invalid data";
        let mut writer = ZlibEncoder::new(
            EncoderWriter::new(iocompat, &BASE64_STANDARD),
            Compression::best(),
        );
        writer.write_all(self.payload).expect(error);
        writer.finish().expect(error);
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Data<'s> {
    payload: &'s [u8],
    sources: &'s [SourceFile],
}

impl<'s> Data<'s> {
    pub fn new(payload: &'s [u8], sources: &'s [SourceFile]) -> Self {
        Self { payload, sources }
    }
}

struct SourceInliner<'s> {
    comment: &'static str,
    files: &'s [SourceFile],
}

impl<'s> fmt::Display for SourceInliner<'s> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Self { comment, files } = *self;

        writeln!(f, "{comment} Generated by `rustcodex`")?;
        writeln!(f, "{comment}")?;
        writeln!(f, "{comment} Heuristically determined source files:")?;

        for file in files {
            writeln!(f, "{comment} SOURCE FILE: {}", file.name())?;
            for line in file.code().lines() {
                writeln!(f, "{comment} {line}")?;
            }
        }
        Ok(())
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Template<'d, T> {
    data: Data<'d>,
    phantom: PhantomData<T>,
}

impl<'d> Template<'d, ()> {
    pub fn new(data: Data<'d>) -> Self {
        Self {
            data,
            phantom: PhantomData,
        }
    }
}

impl<'d, T> Template<'d, T> {
    pub fn transform<U>(self) -> Template<'d, U> {
        Template {
            data: self.data,
            phantom: PhantomData,
        }
    }
}

impl<'d, T: 'd> Template<'d, T>
where
    Self: Display,
{
    pub fn erase(self) -> Box<dyn Display + 'd> {
        Box::new(self)
    }
}

macro_rules! template {
    (
        name: $name:ident
        template: $file:literal
        comment: $comment:literal
    ) => {
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct $name;

        impl fmt::Display for Template<'_, $name> {
            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                let Data { payload, sources } = self.data;

                let source = SourceInliner {
                    files: sources,
                    comment: $comment,
                };
                let payload = Compressor { payload };

                write!(f, include_str!($file), source, payload,)?;

                Ok(())
            }
        }
    };
}

template! {
name: Python
template: "../templates/python.py"
comment: "#"
}
