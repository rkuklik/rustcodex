use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use std::io;
use std::io::ErrorKind;
use std::io::Write;

use base64::prelude::BASE64_STANDARD;
use base64::write::EncoderWriter;
use flate2::write::ZlibEncoder;
use flate2::Compression;

use crate::source::SourceFile;

struct IoCompat<'m, 'f> {
    f: &'m mut Formatter<'f>,
}

impl<'m, 'f> Write for IoCompat<'m, 'f> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let text = std::str::from_utf8(buf)
            .map_err(|error| io::Error::new(ErrorKind::InvalidData, error))?;
        self.f
            .write_str(text)
            .map_err(|error| io::Error::new(ErrorKind::Other, error))?;
        Ok(text.len())
    }
    fn flush(&mut self) -> io::Result<()> {
        Ok(())
    }
}

struct PayloadBuilder<'a> {
    payload: &'a [u8],
    compress: bool,
}

impl<'a> Display for PayloadBuilder<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let Self { payload, compress } = *self;
        let iocompat = IoCompat { f };
        let error = "payload builder wrote invalid data";
        if compress {
            let mut writer = ZlibEncoder::new(
                EncoderWriter::new(iocompat, &BASE64_STANDARD),
                Compression::best(),
            );
            writer.write_all(payload).expect(error);
            writer.finish().expect(error);
        } else {
            let mut writer = EncoderWriter::new(iocompat, &BASE64_STANDARD);
            writer.write_all(payload).expect(error);
            writer.finish().expect(error);
        }

        Ok(())
    }
}

macro_rules! template {
    (
        name: $name:ident
        $(shebang: $shebang:literal)?
        $(comment: $comment:literal)?
        rawloader: $rawloader:literal
        compressloader: $compressloader:literal
        executor: $exec:literal
    ) => {
        pub struct $name<'s> {
            payload: &'s [u8],
            sources: &'s [SourceFile],
            compress: bool,
        }

        impl<'s> $name<'s> {
            pub fn new(payload: &'s [u8], sources: &'s [SourceFile], compress: bool) -> Self {
                Self {
                    payload,
                    sources,
                    compress,
                }
            }
        }

        impl fmt::Display for $name<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let Self {
                    payload,
                    sources,
                    compress,
                } = self;
                let compress = *compress;

                $(
                writeln!(f, concat!("#!", $shebang))?;
                )?

                $(
                writeln!(f, concat!($comment, "Generated by `rustcodex`"))?;
                writeln!(f, $comment)?;
                writeln!(
                    f,
                    concat!($comment, "Heuristically determined source files:")
                )?;

                for source in *sources {
                    writeln!(f, concat!($comment, "SOURCE FILE: {}"), source.name())?;
                    for line in source.code().lines() {
                        writeln!(f, concat!($comment, "{}"), line)?;
                    }
                }
                )?

                write!(
                    f,
                    $exec,
                    PayloadBuilder { payload, compress },
                    if compress {
                        $compressloader
                    } else {
                        $rawloader
                    }
                )?;

                Ok(())
            }
        }
    };
}

template! {
name: Python
shebang: "/usr/bin/env python3"
comment: "# "
rawloader: "base64.standard_b64decode(payload)"
compressloader: "zlib.decompress(base64.standard_b64decode(payload))"
executor: r#"
import base64
import os
import sys
import tempfile
import zlib

payload = """{}"""
binary = {}

fd, name = tempfile.mkstemp()
os.write(fd, binary)
os.close(fd)

os.chmod(name, 0o700)

args = list(sys.argv)
args[0] = name
os.execv(name, args)
"#
}
